var documenterSearchIndex = {"docs":
[{"location":"checkmatrix/#Details-on-check-matrix-operations","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"","category":"section"},{"location":"checkmatrix/#Basic-features-of-check-matrix","page":"Details on check matrix operations","title":"Basic features of check matrix","text":"","category":"section"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"All action on state can be represented as operations on check matrix.\nQuantumLegos which don't connect each other are represented by block diagonal check matrix.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Thus, one needs only one check matrix to represent state.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Generated group from generators represented by check matrix is invariant under row-swap and row-multiplying transforms on the check matrix.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Thus, one can freely perform these row operations on check matrices.","category":"page"},{"location":"checkmatrix/#Construction-of-check-matrices-and-retrieving-features","page":"Details on check matrix operations","title":"Construction of check matrices and retrieving features","text":"","category":"section"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Use CheckMatrix from Matrix{Bool} and checkmatrix from Vector{PauliOp}.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"CheckMatrix\ncheckmatrix","category":"page"},{"location":"checkmatrix/#QuantumLegos.CheckMatrix","page":"Details on check matrix operations","title":"QuantumLegos.CheckMatrix","text":"CheckMatrix\n\nFields\n\ncmat: matrix itself (matrix of Bool since we consider only pauli ops.)\nnlegs: number of columns ÷ 2\nngens: number of rows\n\nConstructor\n\nCheckMatrix(cmat::AbstractMatrix{Bool})\n\nSee also checkmatrix.\n\n\n\n\n\n","category":"type"},{"location":"checkmatrix/#QuantumLegos.checkmatrix","page":"Details on check matrix operations","title":"QuantumLegos.checkmatrix","text":"checkmatrix(stbgens::AbstractVector{T})::CheckMatrix where {T <: PauliOp}\n\nGet CheckMatrix from stabilizer generator.\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Get xpart and zpart of check matrix.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.xpart\nQuantumLegos.zpart","category":"page"},{"location":"checkmatrix/#QuantumLegos.xpart","page":"Details on check matrix operations","title":"QuantumLegos.xpart","text":"xpart(cmat::CheckMatrix)\n\nGet X part (left half) of CheckMatrix.\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/#QuantumLegos.zpart","page":"Details on check matrix operations","title":"QuantumLegos.zpart","text":"zpart(cmat::CheckMatrix)\n\nGet Z part (right half) of CheckMatrix.\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Get generators from check matrix with generators.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"generators","category":"page"},{"location":"checkmatrix/#QuantumLegos.generators","page":"Details on check matrix operations","title":"QuantumLegos.generators","text":"generators(cmat::CheckMatrix)::Vector{PauliOp}\n\nGet generators from CheckMatrix.\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"See also, GeneratedPauliGroup and Base.Set to get group generated by generators.","category":"page"},{"location":"checkmatrix/#Direct-sum","page":"Details on check matrix operations","title":"Direct sum","text":"","category":"section"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Used when adding lego without edge.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.direct_sum","category":"page"},{"location":"checkmatrix/#QuantumLegos.direct_sum","page":"Details on check matrix operations","title":"QuantumLegos.direct_sum","text":"direct_sum(cmat_1::T, cmat_2::T)::T where {T <: CheckMatrix}\n\nReturns block diagonal CheckMatrix consists of cmat_1 and cmat_2.\n\nCheckMatrix transform\n\nWhen adding a lego l with check matrix H_l to a state with check matrix H_s, the resulting check matrix of the state will be\n\nbeginpmatrix\n    H_s  O   \n    O    H_l \nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/#Self-tracing","page":"Details on check matrix operations","title":"Self-tracing","text":"","category":"section"},{"location":"checkmatrix/#self-tracing","page":"Details on check matrix operations","title":"self-tracing","text":"","category":"section"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.self_trace!","category":"page"},{"location":"checkmatrix/#QuantumLegos.self_trace!","page":"Details on check matrix operations","title":"QuantumLegos.self_trace!","text":"self_trace!(cmat::CheckMatrix, col_1::Integer, col_2::Integer)\n\nTake a self-trace of checkmatrix cmat with column col_1 and col_2.\n\nExample\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"During self-tracing, pre-formatting and post-formatting described below is performed.","category":"page"},{"location":"checkmatrix/#pre-formatting","page":"Details on check matrix operations","title":"pre-formatting","text":"","category":"section"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.eliminate_column!","category":"page"},{"location":"checkmatrix/#QuantumLegos.eliminate_column!","page":"Details on check matrix operations","title":"QuantumLegos.eliminate_column!","text":"eliminate_column!(\n    cmat::CheckMatrix,\n    col::Integer,\n    avoid_row::AbstractVector{T},\n)::Union{Nothing, Int64} where {T <: Integer}\n\nPerform Gauss Elimination on col. Keep only one 1 on col and remove from other rows by performing multiplication. Choose row not in avoid_row. If all rows with 1 on col are in avoid_row, then the last row of them is chose to keep 1. If all rows on col is 0, return nothing.\n\nReturn\n\nRow index which have 1 on col. If all row on col is 0, return nothing.\n\nExample\n\njulia> ex_cmat = CheckMatrix(Bool[1 0 1 0; 1 1 1 1])\nCheckMatrix with 2 generators, 2 legs:\n  1  0 | 1  0\n  1  1 | 1  1\n\njulia> QuantumLegos.eliminate_column!(ex_cmat, 1, Int64[])\n1\n\njulia> ex_cmat\nCheckMatrix with 2 generators, 2 legs:\n  1  0 | 1  0\n  0  1 | 0  1\n\n\n\n\n\neliminate_column!(cmat::CheckMatrix, col::Integer,\navoid_row::AbstractVector{T}) where {T <: Union{Nothing, Integer}}\n\navoid_row can include Nothing, which is ignored in actual evaluation.\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.align_row!","category":"page"},{"location":"checkmatrix/#QuantumLegos.align_row!","page":"Details on check matrix operations","title":"QuantumLegos.align_row!","text":"align_row!(m::AbstractMatrix, row::Integer, occupied::Vector{Union{Nothing, Integer}}) -> Integer\nalign_row!(m::AbstractMatrix, row::Nothing, occupied::Vector{Union{Nothing, Integer}}) -> Nothing\n\nSwap row at row in m and row at next to the maximum in occupied. occupied is supposed to be a list of returns from eliminate_column!. If row is in occupied, do nothing and returns row. If row is nothing, return nothing.\n\nArguments\n\nm::AbstractMatrix: mutated\nrow::Union{Nothing, Integer}: row to be aligned\noccupied::Vector{Union{Nothing, Integer}}: indices of already occupied rows. row will be next to these rows.\n\nReturn\n\nRow index where row is moved.\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.align_row!","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"By this process, all columns to be traced have 1s on only 1st to 4th rows. So during QuantumLegos.self_trace!, all stabilizers generated from top three rows are calculated and perform operator matching.","category":"page"},{"location":"checkmatrix/#post-formatting","page":"Details on check matrix operations","title":"post-formatting","text":"","category":"section"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"Remove rows which are linear combinations of other rows.","category":"page"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.ref!","category":"page"},{"location":"checkmatrix/#QuantumLegos.ref!","page":"Details on check matrix operations","title":"QuantumLegos.ref!","text":"ref!(cmat::CheckMatrix) -> Int\n\nConvert cmat to row echelon form.\n\nReturns rank of check matrix.\n\nExamples\n\njulia> cmat = CheckMatrix(Bool[\n           1 0 1 0 1 1 0 1\n           0 1 0 0 0 1 0 0\n           1 1 1 0 1 0 1 1\n           0 1 0 0 0 1 0 0\n       ])\nCheckMatrix with 4 generators, 4 legs:\n  1  0  1  0 | 1  1  0  1\n  0  1  0  0 | 0  1  0  0\n  1  1  1  0 | 1  0  1  1\n  0  1  0  0 | 0  1  0  0\n\n\njulia> QuantumLegos.ref!(cmat)\n3\n\njulia> cmat\nCheckMatrix with 4 generators, 4 legs:\n  1  0  1  0 | 1  1  0  1\n  0  1  0  0 | 0  1  0  0\n  0  0  0  0 | 0  0  1  0\n  0  0  0  0 | 0  0  0  0\n\n\n\n\n\n\n","category":"function"},{"location":"checkmatrix/","page":"Details on check matrix operations","title":"Details on check matrix operations","text":"QuantumLegos.eliminate_dependent_row!","category":"page"},{"location":"checkmatrix/#QuantumLegos.eliminate_dependent_row!","page":"Details on check matrix operations","title":"QuantumLegos.eliminate_dependent_row!","text":"eliminate_dependent_row!(cmat::CheckMatrix) -> CheckMatrix\n\nRemove dependent rows to keep only independent generators.\n\n\n\n\n\n","category":"function"},{"location":"distance/#How-to-calculate-code-distance-from-the-state.","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"","category":"section"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"warning: WIP\nThis document is not fully completed.","category":"page"},{"location":"distance/#Definition-of-code-distance.","page":"How to calculate code distance from the state.","title":"Definition of code distance.","text":"","category":"section"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Let's consider encoding circuit with 1 logical bit and k physical qubits[1]. Then this encoding has two physical basis, ket0_L and ket1_L. The distance of this encoding is the minimum bit flip required to convert between ket0_L and ket1_L.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"[1]: Not all state can be formalized like this. TODO","category":"page"},{"location":"distance/#Classification-of-the-stabilizers.","page":"How to calculate code distance from the state.","title":"Classification of the stabilizers.","text":"","category":"section"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"When treating State, the logical leg is not assigned and one can treat all stabilizers equally. However, if logical leg is assigned to the state, these stabilizers can be classified to 4 groups.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"stabilizers on physical qubits\n​barX, which corresponds to logical X\n​barZ, which corresponds to logical Z\n​barY, which corresponds to logical Y","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Let ketV is the dual state of the channel or encoding map n 1 d,","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"distance = min_S in stabilizers left i mid barZ_i  S_i right","category":"page"},{"location":"distance/#Calculating-code-distance-from-the-check-matrix.","page":"How to calculate code distance from the state.","title":"Calculating code distance from the check matrix.","text":"","category":"section"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"TODO: nor required if the performance doesn't matter.","category":"page"},{"location":"distance/#Examples","page":"How to calculate code distance from the state.","title":"Examples","text":"","category":"section"},{"location":"distance/#[[5,-1,-3]]-code","page":"How to calculate code distance from the state.","title":"5 1 3 code","text":"","category":"section"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"​5 1 3 code has 4 stabilizers generators, XZZXI IXZZX XIXZZ ZXIXZ and 2 logical operators, barX = XXXXX and barZ = ZZZZZ. Therefore, stabilizer generators for the corresponding state 6 0 is IXZZXI IIXZZX IXIXZZ IZXIXZ XXXXXX ZZZZZZ.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Let's construct 6 0 state on QuantumLegos.jl.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"julia> using QuantumLegos\n\njulia> stab_513 = pauliop.([\"IXZZXI\", \"IIXZZX\", \"IXIXZZ\", \"IZXIXZ\", \"XXXXXX\", \"ZZZZZZ\"])\n6-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IXZZXI\")\n pauliop(\"IIXZZX\")\n pauliop(\"IXIXZZ\")\n pauliop(\"IZXIXZ\")\n pauliop(\"XXXXXX\")\n pauliop(\"ZZZZZZ\")\n\njulia> lego_513 = Lego(stab_513)\nLego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IXZZXI\"), pauliop(\"IIXZZX\"), pauliop(\"IXIXZZ\"), pauliop(\"IZXIXZ\"), pauliop(\"XXXXXX\"), pauliop(\"ZZZZZZ\")])\n\njulia> state_513 = State([lego_513], edge.([]))\nState(Lego[Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IXZZXI\"), pauliop(\"IIXZZX\"), pauliop(\"IXIXZZ\"), pauliop(\"IZXIXZ\"), pauliop(\"XXXXXX\"), pauliop(\"ZZZZZZ\")])], Tuple{LegoLeg, LegoLeg}[], CheckMatrix(Bool[0 1 … 0 0; 0 0 … 1 0; … ; 1 1 … 0 0; 0 0 … 1 1], 6, 6))\n","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Then collect generators of the state.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"julia> normalizers = state_513.cmat |> generators |> GeneratedPauliGroup |> collect\n64-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIIIII\")\n pauliop(\"IXZZXI\")\n pauliop(\"IIXZZX\")\n pauliop(\"IXYIYX\")\n pauliop(\"IXIXZZ\")\n pauliop(\"IIZYYZ\")\n pauliop(\"IXXYIY\")\n pauliop(\"IIYXXY\")\n pauliop(\"IZXIXZ\")\n pauliop(\"IYYZIZ\")\n ⋮\n pauliop(\"YYIZZI\")\n pauliop(\"YXZYZX\")\n pauliop(\"YIIXYX\")\n pauliop(\"YXYXII\")\n pauliop(\"YIXYXI\")\n pauliop(\"YIZZIY\")\n pauliop(\"YXIIXY\")\n pauliop(\"YIYIZZ\")\n pauliop(\"YXXZYZ\")\n","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Get stabilizer and normalizers of the 5 1 3 code by assigning the first leg as logical.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"julia> stabs = filter(x -> x[1] == PauliOps.I, normalizers)\n16-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIIIII\")\n pauliop(\"IXZZXI\")\n pauliop(\"IIXZZX\")\n pauliop(\"IXYIYX\")\n pauliop(\"IXIXZZ\")\n pauliop(\"IIZYYZ\")\n pauliop(\"IXXYIY\")\n pauliop(\"IIYXXY\")\n pauliop(\"IZXIXZ\")\n pauliop(\"IYYZIZ\")\n pauliop(\"IZIZYY\")\n pauliop(\"IYZIZY\")\n pauliop(\"IYXXYI\")\n pauliop(\"IZYYZI\")\n pauliop(\"IYIYXX\")\n pauliop(\"IZZXIX\")\n\njulia> norm_x = filter(x -> x[1] == PauliOps.X, normalizers)\n16-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"XXXXXX\")\n pauliop(\"XIYYIX\")\n pauliop(\"XXIYYI\")\n pauliop(\"XIZXZI\")\n pauliop(\"XIXIYY\")\n pauliop(\"XXYZZY\")\n pauliop(\"XIIZXZ\")\n pauliop(\"XXZIIZ\")\n pauliop(\"XYIXIY\")\n pauliop(\"XZZYXY\")\n pauliop(\"XYXYZZ\")\n pauliop(\"XZYXYZ\")\n pauliop(\"XZIIZX\")\n pauliop(\"XYZZYX\")\n pauliop(\"XZXZII\")\n pauliop(\"XYYIXI\")\n\njulia> norm_y = filter(x -> x[1] == PauliOps.Y, normalizers)\n16-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"YYYYYY\")\n pauliop(\"YZXXZY\")\n pauliop(\"YYZXXZ\")\n pauliop(\"YZIYIZ\")\n pauliop(\"YZYZXX\")\n pauliop(\"YYXIIX\")\n pauliop(\"YZZIYI\")\n pauliop(\"YYIZZI\")\n pauliop(\"YXZYZX\")\n pauliop(\"YIIXYX\")\n pauliop(\"YXYXII\")\n pauliop(\"YIXYXI\")\n pauliop(\"YIZZIY\")\n pauliop(\"YXIIXY\")\n pauliop(\"YIYIZZ\")\n pauliop(\"YXXZYZ\")\n\njulia> norm_z = filter(x -> x[1] == PauliOps.Z, normalizers)\n16-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"ZZZZZZ\")\n pauliop(\"ZYIIYZ\")\n pauliop(\"ZZYIIY\")\n pauliop(\"ZYXZXY\")\n pauliop(\"ZYZYII\")\n pauliop(\"ZZIXXI\")\n pauliop(\"ZYYXZX\")\n pauliop(\"ZZXYYX\")\n pauliop(\"ZIYZYI\")\n pauliop(\"ZXXIZI\")\n pauliop(\"ZIZIXX\")\n pauliop(\"ZXIZIX\")\n pauliop(\"ZXYYXZ\")\n pauliop(\"ZIXXIZ\")\n pauliop(\"ZXZXYY\")\n pauliop(\"ZIIYZY\")\n","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"These normalizers are generated from one logical operator and stabilizers.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"julia> map(x -> x .* pauliop(\"XXXXXX\"), stabs) |> Set == Set(norm_x)\ntrue\n\njulia> map(x -> x .* pauliop(\"ZZZZZZ\"), stabs) |> Set == Set(norm_x)\nfalse\n\njulia> map(x -> x .* pauliop(\"ZZZZZZ\"), stabs) |> Set == Set(norm_z)\ntrue\n\njulia> map(x -> x .* pauliop(\"YYYYYY\"), stabs) |> Set == Set(norm_y)\ntrue\n\njulia> using IterTools\n\njulia> groupby(x -> x[1], normalizers) .|> Set == Set.([stabs, norm_x, norm_z, norm_y])\ntrue\n","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Define a function to get weight of the operator.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"julia> function weight(x, i = 1)\n           count(x[i:end] .!= PauliOps.I)\n       end\nweight (generic function with 2 methods)\n\njulia> weight(pauliop(\"XIXIXI\"))\n3\n\njulia> weight(pauliop(\"XIXIXI\"), 2)\n2\n","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Calculate coefficients of enumerator polynomial.","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"julia> using DataStructures\n\njulia> stabs .|> weight |> counter\nAccumulator{Int64, Int64} with 2 entries:\n  0 => 1\n  4 => 15\n\njulia> function weight(i::Integer)\n           Base.Fix2(weight, i)\n       end\nweight (generic function with 3 methods)\n\njulia> normalizers .|> weight(2) |> counter\nAccumulator{Int64, Int64} with 4 entries:\n  0 => 1\n  4 => 15\n  5 => 18\n  3 => 30\n\njulia> [norm_x..., norm_y..., norm_z...] .|> weight(2) |> counter\nAccumulator{Int64, Int64} with 2 entries:\n  5 => 18\n  3 => 30\n\njulia> [norm_x..., norm_y..., norm_z...] .|> weight(2) |> counter |> keys |> minimum\n3\n","category":"page"},{"location":"distance/","page":"How to calculate code distance from the state.","title":"How to calculate code distance from the state.","text":"Code distance of the encoding is the minimum degree of the non-zero term in the normalizer's polynomial(B) and not in the stabilizer's polynomial(A). So the code distance of this encoding is 3.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumLegos","category":"page"},{"location":"#QuantumLegos","page":"Home","title":"QuantumLegos","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumLegos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All contents:","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"#CheckMatrix-and-defining-Lego","page":"Home","title":"CheckMatrix and defining Lego","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using QuantumLegos\n\njulia> stabilizers = pauliop.([\"IIXXXX\", \"IIZZZZ\", \"ZIZZII\", \"IZZIZI\", \"IXXXII\", \"XIXIXI\"])\n6-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIXXXX\")\n pauliop(\"IIZZZZ\")\n pauliop(\"ZIZZII\")\n pauliop(\"IZZIZI\")\n pauliop(\"IXXXII\")\n pauliop(\"XIXIXI\")\n\njulia> cmat = checkmatrix(stabilizers)\nCheckMatrix with 6 generators, 6 legs:\n  0  0  1  1  1  1 | 0  0  0  0  0  0\n  0  0  0  0  0  0 | 0  0  1  1  1  1\n  0  0  0  0  0  0 | 1  0  1  1  0  0\n  0  0  0  0  0  0 | 0  1  1  0  1  0\n  0  1  1  1  0  0 | 0  0  0  0  0  0\n  1  0  1  0  1  0 | 0  0  0  0  0  0\n\n\njulia> cmat.nlegs\n6\n\njulia> cmat.ngens\n6\n\njulia> cmat.cmat\n6×12 Matrix{Bool}:\n 0  0  1  1  1  1  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  1  1  1  1\n 0  0  0  0  0  0  1  0  1  1  0  0\n 0  0  0  0  0  0  0  1  1  0  1  0\n 0  1  1  1  0  0  0  0  0  0  0  0\n 1  0  1  0  1  0  0  0  0  0  0  0\n\njulia> # define lego\n\njulia> lego = Lego(stabilizers)\nLego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])\n\njulia> lego.stabgens |> checkmatrix\nCheckMatrix with 6 generators, 6 legs:\n  0  0  1  1  1  1 | 0  0  0  0  0  0\n  0  0  0  0  0  0 | 0  0  1  1  1  1\n  0  0  0  0  0  0 | 1  0  1  1  0  0\n  0  0  0  0  0  0 | 0  1  1  0  1  0\n  0  1  1  1  0  0 | 0  0  0  0  0  0\n  1  0  1  0  1  0 | 0  0  0  0  0  0\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"pauliop\ncheckmatrix and CheckMatrix\nLego","category":"page"},{"location":"#Defining-and-Updating-State","page":"Home","title":"Defining and Updating State","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using QuantumLegos\n\njulia> stabilizers = pauliop.([\"IIXXXX\", \"IIZZZZ\", \"ZIZZII\", \"IZZIZI\", \"IXXXII\", \"XIXIXI\"])\n6-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIXXXX\")\n pauliop(\"IIZZZZ\")\n pauliop(\"ZIZZII\")\n pauliop(\"IZZIZI\")\n pauliop(\"IXXXII\")\n pauliop(\"XIXIXI\")\n\njulia> lego = Lego(stabilizers)\nLego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])\n\njulia> # state with 1 lego, 0 leg\n\njulia> st = State([lego, ], Tuple{LegoLeg, LegoLeg}[])\nState(Lego[Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])], Tuple{LegoLeg, LegoLeg}[], CheckMatrix(Bool[0 0 … 0 0; 0 0 … 1 1; … ; 0 1 … 0 0; 1 0 … 0 0], 6, 6))\n\njulia> st.cmat.cmat\n6×12 Matrix{Bool}:\n 0  0  1  1  1  1  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  1  1  1  1\n 0  0  0  0  0  0  1  0  1  1  0  0\n 0  0  0  0  0  0  0  1  1  0  1  0\n 0  1  1  1  0  0  0  0  0  0  0  0\n 1  0  1  0  1  0  0  0  0  0  0  0\n\njulia> add_lego!(st, lego)\nState(Lego[Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")]), Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])], Tuple{LegoLeg, LegoLeg}[], CheckMatrix(Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], 12, 12))\n\njulia> st.cmat.cmat\n12×24 Matrix{Bool}:\n 0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  1  0  1  1  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  0  1  0  0  0  0  0  0  0\n 0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 1  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  1  1  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  0  1  0\n 0  0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  1  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> # state with 2 legos, 0 leg\n\njulia> st2 = State([lego, lego], Tuple{LegoLeg, LegoLeg}[])\nState(Lego[Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")]), Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])], Tuple{LegoLeg, LegoLeg}[], CheckMatrix(Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], 12, 12))\n\njulia> st == st2\ntrue","category":"page"},{"location":"#2-Lego-1-edge-state","page":"Home","title":"2 Lego 1 edge state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using QuantumLegos\n\njulia> stabilizers = pauliop.([\"IIXXXX\", \"IIZZZZ\", \"ZIZZII\", \"IZZIZI\", \"IXXXII\", \"XIXIXI\"])\n6-element Vector{StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIXXXX\")\n pauliop(\"IIZZZZ\")\n pauliop(\"ZIZZII\")\n pauliop(\"IZZIZI\")\n pauliop(\"IXXXII\")\n pauliop(\"XIXIXI\")\n\njulia> lego = Lego(stabilizers)\nLego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])\n\njulia> state = State([lego, lego], edge.([((1, 3), (2, 3))]))\nState(Lego[Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")]), Lego{6}(6, StaticArraysCore.SVector{6, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXXXX\"), pauliop(\"IIZZZZ\"), pauliop(\"ZIZZII\"), pauliop(\"IZZIZI\"), pauliop(\"IXXXII\"), pauliop(\"XIXIXI\")])], Tuple{LegoLeg, LegoLeg}[(LegoLeg(1, 3), LegoLeg(2, 3))], CheckMatrix(Bool[1 0 … 0 0; 0 1 … 0 0; … ; 0 0 … 1 1; 0 0 … 0 1], 10, 10))\n\njulia> state.cmat\nCheckMatrix with 10 generators, 10 legs:\n  1  0  1  0  1  0  0  0  0  0 | 0  0  0  0  0  0  0  0  0  0\n  0  1  0  1  1  0  0  0  0  0 | 0  0  0  0  0  0  0  0  0  0\n  0  0  1  1  1  0  0  1  1  1 | 0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  1  0  1  0  1 | 0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  1  0  1  1 | 0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0 | 1  0  0  1  1  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0 | 0  1  1  0  1  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0 | 0  0  1  1  1  0  0  1  1  1\n  0  0  0  0  0  0  0  0  0  0 | 0  0  0  0  0  1  0  0  1  1\n  0  0  0  0  0  0  0  0  0  0 | 0  0  0  0  0  0  1  1  0  1\n\n\njulia> pg = state.cmat |> generators |> GeneratedPauliGroup\nGeneratedPauliGroup{10}(StaticArraysCore.SVector{10, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"XIXIXIIIII\"), pauliop(\"IXIXXIIIII\"), pauliop(\"IIXXXIIXXX\"), pauliop(\"IIIIIXIXIX\"), pauliop(\"IIIIIIXIXX\"), pauliop(\"ZIIZZIIIII\"), pauliop(\"IZZIZIIIII\"), pauliop(\"IIZZZIIZZZ\"), pauliop(\"IIIIIZIIZZ\"), pauliop(\"IIIIIIZZIZ\")], IterTools.Subsets{Vector{StaticArraysCore.SVector{N, QuantumLegos.PauliOps.SinglePauliOp} where N}}(StaticArraysCore.SVector{N, QuantumLegos.PauliOps.SinglePauliOp} where N[pauliop(\"XIXIXIIIII\"), pauliop(\"IXIXXIIIII\"), pauliop(\"IIXXXIIXXX\"), pauliop(\"IIIIIXIXIX\"), pauliop(\"IIIIIIXIXX\"), pauliop(\"ZIIZZIIIII\"), pauliop(\"IZZIZIIIII\"), pauliop(\"IIZZZIIZZZ\"), pauliop(\"IIIIIZIIZZ\"), pauliop(\"IIIIIIZZIZ\")]))\n\njulia> pauliop(\"XIIXIXIIXI\") in pg\ntrue\n","category":"page"},{"location":"#Internal(how-it-works)","page":"Home","title":"Internal(how it works)","text":"","category":"section"},{"location":"#Notes-on-Overall-flow","page":"Home","title":"Notes on Overall flow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Details on [1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"state is translated to a single check matrix\nthe size is ≤ N times 2N where N is maximum number of lego logs.\nany contraction can be performed on this single check matrix\nif the check matrix can be represented as direct sum of matrices with k N columns where k  ℕ, then they are not contracted","category":"page"},{"location":"#Construction-of-State","page":"Home","title":"Construction of State","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Construction of State is completed by calling State constructor recursively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Construct State without edge. Just adding legos. Checkmatrix is just a direct sum of each lego's checkmatrix\nConcatenate each edges. During this operation, self tracing of checkmatrix is evaluated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each constructor calls action function (which is a map from State to State). Therefore, action functions can be used both for direct construction of State and action application to State during the game.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumLegos]\nPages   = [\"game.jl\"]","category":"page"},{"location":"#QuantumLegos.Lego","page":"Home","title":"QuantumLegos.Lego","text":"Quantum lego with N legs.\n\nFields\n\nnlegs::Int64: number of legs, equals N\nstabgens::SVector{N, PauliOp{N}}: stabilizer generators. vector of PauliOp\n\nConstructor\n\nLego([nlegs::Integer], stabgens::AbstractVector{PauliOp{N}})\n\nConstructor for Lego. nlegs is optional (default is length of the first stabilizer generator).\n\nExample\n\njulia> stabgens = pauliop.([\"II\", \"XX\"])\n2-element Vector{StaticArraysCore.SVector{2, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"II\")\n pauliop(\"XX\")\n\njulia> Lego(stabgens)\nLego{2}(2, StaticArraysCore.SVector{2, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"II\"), pauliop(\"XX\")])\n\n\n\n\n\n","category":"type"},{"location":"#QuantumLegos.LegoLeg","page":"Home","title":"QuantumLegos.LegoLeg","text":"mutable struct State\n\nTo be used in State.\n\nFields\n\nlego_id::Int64: index in legos in State\nedge_id::Int64: index in Lego in legos in State. No validation check included in LegoLeg.\n\nExample\n\njulia> x = LegoLeg.([(2, 1), (1, 1), (1, 0)])\n3-element Vector{LegoLeg}:\n LegoLeg(2, 1)\n LegoLeg(1, 1)\n LegoLeg(1, 0)\n\njulia> sort(x)\n3-element Vector{LegoLeg}:\n LegoLeg(1, 0)\n LegoLeg(1, 1)\n LegoLeg(2, 1)\n\n\n\n\n\n","category":"type"},{"location":"#QuantumLegos.State","page":"Home","title":"QuantumLegos.State","text":"mutable struct State\n\nState (in p.4)\n\nFields\n\nlegos: Vector{Lego}\nedges: Vector of ((lego_i, leg_n), (lego_j, leg_m)).   Each element is sorted (i.e. lego_i < lego_j or lego_i == lego_j && leg_n < leg_m).   This feature is used in is_connected_to_firstlego.\ncmat::CheckMatrix: CheckMatrix\n\nConstructor\n\nState(legos::Vector{Lego{N}}, edges::Vector{Tuple{LegoLeg, LegoLeg}})\n\nMethods with\n\nadd_lego!\nadd_edge!\n\nExample\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"#QuantumLegos._naive_distance-Tuple{State}","page":"Home","title":"QuantumLegos._naive_distance","text":"Calculate distance. Use minimum distance of all generated normalizers.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.add_edge!-Tuple{State, LegoLeg, LegoLeg}","page":"Home","title":"QuantumLegos.add_edge!","text":"add_edge!(state::State, leg_1::LegoLeg, leg_2::LegoLeg)::State\n\nAdd a new edge between leg_1 and leg_2, updating state.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.add_lego!-Tuple{State, Lego}","page":"Home","title":"QuantumLegos.add_lego!","text":"add_lego!(state::State, lego::Lego) -> State\n\nAdd a new lego, updating state.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.cmat_index-Tuple{State, LegoLeg}","page":"Home","title":"QuantumLegos.cmat_index","text":"cmat_index(state::State, leg::LegoLeg)::Int64\n\nGet column index corresponds to leg in check matrix of state. If given leg is already connected, it throws ArgumentError. If given lego_id of leg is out of state.legos, throws ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.distance-Tuple{State}","page":"Home","title":"QuantumLegos.distance","text":"distance(state::State) -> Int\n\nCalculate code distance when the first leg of state is assigned as logical.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.edge","page":"Home","title":"QuantumLegos.edge","text":"Helper function to create Tuple{LegoLeg, LegoLeg} to represent edge.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumLegos.edge-Union{Tuple{NTuple{4, T}}, Tuple{T}} where T<:Integer","page":"Home","title":"QuantumLegos.edge","text":"edge(t::Tuple{T, T, T, T}) where {T <: Integer}\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.edge-Union{Tuple{Tuple{T, T}}, Tuple{T}} where T<:Tuple{Integer, Integer}","page":"Home","title":"QuantumLegos.edge","text":"edge(t::Tuple{T, T}) where {T <: Tuple{Integer, Integer}}\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.edge-Union{Tuple{T}, NTuple{4, T}} where T<:Integer","page":"Home","title":"QuantumLegos.edge","text":"edge(x::T, y::T, z::T, w::T) where {T <: Integer}\n\n\n\n\n\n","category":"method"},{"location":"#QuantumLegos.is_connected_to_firstlego-Tuple{State}","page":"Home","title":"QuantumLegos.is_connected_to_firstlego","text":"is_connected_to_firstlego(state::State)::BitVector\n\nReturns vector which stores whether each lego is connected to the first lego.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"[1]: C. Cao and B. Lackey, ‘Approximate Bacon-Shor code and holography’, J. High Energ. Phys., vol. 2021, no. 5, p. 127, May 2021, doi: 10.1007/JHEP05(2021)127.","category":"page"},{"location":"pauliops/#PauliOps","page":"PauliOps","title":"PauliOps","text":"","category":"section"},{"location":"pauliops/","page":"PauliOps","title":"PauliOps","text":"submodule","category":"page"},{"location":"pauliops/#Example","page":"PauliOps","title":"Example","text":"","category":"section"},{"location":"pauliops/","page":"PauliOps","title":"PauliOps","text":"julia> using QuantumLegos\n\njulia> p = PauliOps.single_pauliop('I')\nI::SinglePauliOp = 0\n\njulia> typeof(p)\nEnum QuantumLegos.PauliOps.SinglePauliOp:\nI = 0\nX = 1\nY = 2\nZ = 3\n\njulia> pauliop(\"IXYZ\")\n4-element PauliOp:\n I::SinglePauliOp = 0\n X::SinglePauliOp = 1\n Y::SinglePauliOp = 2\n Z::SinglePauliOp = 3\n\njulia> typeof(ans)\nSVector{4, SinglePauliOp} (alias for StaticArraysCore.SArray{Tuple{4}, QuantumLegos.PauliOps.SinglePauliOp, 1, 4})\n\njulia> PauliOps.I * PauliOps.X\nX::SinglePauliOp = 1\n\njulia> PauliOps.X * PauliOps.Z\nY::SinglePauliOp = 2\n\njulia> pauliop(\"IIX\") .* pauliop(\"XIY\")\n3-element PauliOp:\n X::SinglePauliOp = 1\n I::SinglePauliOp = 0\n Z::SinglePauliOp = 3","category":"page"},{"location":"pauliops/#API","page":"PauliOps","title":"API","text":"","category":"section"},{"location":"pauliops/","page":"PauliOps","title":"PauliOps","text":"Modules = [PauliOps]","category":"page"},{"location":"pauliops/#QuantumLegos.PauliOps","page":"PauliOps","title":"QuantumLegos.PauliOps","text":"Pauli operator\n\n\n\n\n\n","category":"module"},{"location":"pauliops/#QuantumLegos.PauliOps.GeneratedPauliGroup","page":"PauliOps","title":"QuantumLegos.PauliOps.GeneratedPauliGroup","text":"struct GeneratedPauliGroup\n\nIterator for group generated from gens.\n\nGeneratedPauliGroup(gens::AbstractVector{T}) where {T <: PauliOp}\n\nExamples\n\njulia> gens = pauliop.([\"IIXX\", \"IZZI\"])\n2-element Vector{StaticArraysCore.SVector{4, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIXX\")\n pauliop(\"IZZI\")\n\njulia> g = PauliOps.GeneratedPauliGroup(gens)\nGeneratedPauliGroup{4}(StaticArraysCore.SVector{4, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXX\"), pauliop(\"IZZI\")], IterTools.Subsets{Vector{StaticArraysCore.SVector{4, QuantumLegos.PauliOps.SinglePauliOp}}}(StaticArraysCore.SVector{4, QuantumLegos.PauliOps.SinglePauliOp}[pauliop(\"IIXX\"), pauliop(\"IZZI\")]))\n\njulia> collect(g)\n4-element Vector{StaticArraysCore.SVector{4, QuantumLegos.PauliOps.SinglePauliOp}}:\n pauliop(\"IIII\")\n pauliop(\"IIXX\")\n pauliop(\"IZZI\")\n pauliop(\"IZYX\")\n\n\n\n\n\n","category":"type"},{"location":"pauliops/#QuantumLegos.PauliOps.PauliOp","page":"PauliOps","title":"QuantumLegos.PauliOps.PauliOp","text":"PauliOp{N}\n\nPauli operator on multiple qubits.\n\n\n\n\n\n","category":"type"},{"location":"pauliops/#QuantumLegos.PauliOps.SinglePauliOp","page":"PauliOps","title":"QuantumLegos.PauliOps.SinglePauliOp","text":"@enum SinglePauliOp begin\n    I\n    X\n    Y\n    Z\nend\n\nPauli Operator on a single qubit.\n\n\n\n\n\n","category":"type"},{"location":"pauliops/#QuantumLegos.PauliOps.pauliop-Tuple{AbstractString}","page":"PauliOps","title":"QuantumLegos.PauliOps.pauliop","text":"pauliop(str::AbstractString)::PauliOp\n\nConvert str to PauliOp.\n\n\n\n\n\n","category":"method"},{"location":"pauliops/#QuantumLegos.PauliOps.single_pauliop-Tuple{Char}","page":"PauliOps","title":"QuantumLegos.PauliOps.single_pauliop","text":"single_pauliop(char::Char)::SinglePauliOp\n\nConvert char to SinglePauliOp.\n\n\n\n\n\n","category":"method"},{"location":"pauliops/#QuantumLegos.PauliOps.weight","page":"PauliOps","title":"QuantumLegos.PauliOps.weight","text":"weight(p::PauliOp, [init = 1])\n\nWeight of the operator p, i.e. non I operator.\n\n\n\n\n\n","category":"function"},{"location":"pauliops/#QuantumLegos.PauliOps.xweight","page":"PauliOps","title":"QuantumLegos.PauliOps.xweight","text":"xweight(p::PauliOp, [init = 1])\n\nNumber of X Y in p.\n\n\n\n\n\n","category":"function"},{"location":"pauliops/#QuantumLegos.PauliOps.zweight","page":"PauliOps","title":"QuantumLegos.PauliOps.zweight","text":"zweight(p::PauliOp, [init = 1])\n\nNumber of Z Y in p. a\n\n\n\n\n\n","category":"function"}]
}
